\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

% Math packages
\usepackage{amsmath,amssymb,amsfonts}

% Algorithms
\usepackage{algorithmic}

% Figures and graphics
\usepackage{graphicx}       % For including graphics
\usepackage{float}          % For figure placement control
\usepackage{subcaption}     % For subfigures

% Text and fonts
\usepackage{textcomp}       % For special symbols like ¬∞

% Colors
\usepackage{xcolor}         % For color definitions

% Tables
\usepackage{booktabs}       % For professional-looking tables

% Bibliography
\usepackage[numbers,sort&compress]{natbib}
\bibliographystyle{unsrtnat}

% Encoding and spacing
\usepackage[utf8]{inputenc} % UTF-8 support
\usepackage{titlesec}       % For customizing section titles
\usepackage{setspace}       % For line spacing control

\definecolor{HKS66}{RGB}{118,185,0}

%verbesserte Datums ausgabe
\usepackage[ddmmyyyy]{datetime}
\renewcommand{\dateseparator}{.}

\begin{document}

\begin{titlepage}
    \thispagestyle{empty}
    \parindent=0pt
    \begin{minipage}[b]{0.35\textwidth}
        \includegraphics[width=\textwidth]{Pictures/htw-berlin_logo.jpg}
    \end{minipage}
    \begin{minipage}[b]{0.65\textwidth}
        ~
    \end{minipage}

    \vspace{0.5em}
    \textcolor{HKS66}{\rule{\linewidth}{0.4mm}}

    \vspace*{\stretch{0.5}}

    % === TITEL UND ART DER ARBEIT ===
    \begin{center}
        {\LARGE\bfseries\color{HKS66} Skriptgesteuerte Erstellung und Konfiguration von Windows-basierten virtuellen Maschinen in Hyper-V mittels PowerShell} \\[1em]
        \textcolor{HKS66}{\rule{\linewidth}{0.4mm}}\\[1.5em]
        {\LARGE\bfseries Bachelorarbeit}
    \end{center}

    \vspace*{\stretch{0.5}}

    % === AUTOR UND HOCHSCHULE ===
    \begin{center}
        \normalsize % (Standardgr√∂√üe) ‚Äî du kannst hier z.‚ÄØB. \large draus machen
        von\\[2ex]
        {\bfseries\large\fontsize{14pt}{16pt}\selectfont Kevin H√ºbner}\\[2ex]
        Matrikelnummer: 570746\\[4ex]
        {\bfseries\fontsize{13pt}{15pt}\selectfont Fachbereich 1: Computer Engineering}\\
        Hochschule f√ºr Technik und Wirtschaft Berlin\\[2ex]
    \end{center}

    \vspace*{\stretch{1}}

    % === DATUM ===
    \begin{center}
        {\Large Datum: Berlin, \today}
    \end{center}

    \vspace*{\stretch{1}}

    % === BEGUTACHTER ===
\begin{center}
    \begin{tabular}{ll}
        {\bfseries\large Erstgutachten:} &  \\
        {\bfseries\large Zweitgutachten:} &  \\
    \end{tabular}
\end{center}

    \vspace*{\stretch{2}}

    \textcolor{HKS66}{\rule{\linewidth}{0.4mm}}

\end{titlepage}


\newpage

Theorie:
- PowerShell
- Hyper V / Failovercluster
    - %https://d1wqtxts1xzle7.cloudfront.net/67117145/Benchmarking_the_Performance_of_Microsof20210505-17699-j1sicg.pdf?1738414388=&response-content-disposition=inline%3B+filename%3DBenchmarking_the_Performance_of_Microsof.pdf&Expires=1754378862&Signature=RcQUcGdtIdVThfq~KQwpd1Mhlu1Gi7eJ0IHp-s3QmbQzw~IWOmBXHWxwhm7u-E8WV8BRwc39B13YzHA8qFK0~AdbZrPkfIzpR8uc-3WzoAa4NtFEUx0SMN~N7FYnls8y10jem9~FxcF6TszNB~j9SqSazGu2RjDbm3w09DbYWmmxE~2bJaAUU8cCSCZ9dMxGTVWkRPf68DcdPKp-NTvUdgMtPWVT~2O5SmrmWenthcI73SKH~D8SKrU3WZg8jNI731-B-Q8lxTeYDo8IBpf6J9r9atNdVYycWszi2hE2l0dXdJ8OQ-FBjR9SXcryqfrbkGvD6KhA9PWD0OlpL55NXQ__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA
    - two variants hyper v on windows and on windows server
    - requires a processor with hardware assisted virtualizaton
    - based on micro kernelized hypervisors 
        - host os provides drivers
        - virtualizaton runs in the parent partition and has access to hardware devices
        - parent creates child
            - childs have no access to hardware
    -%https://acta.fih.upt.ro/pdf/2016-2/ACTA-2016-2-15.pdf (performance analysis of server system virtualization implemented using hyper v hypervisor)
        - works on the os. 
        - runs on the hardware, under the os
    - % https://www.fujitsu.com/global/documents/about/resources/publications/fstj/archives/vol47-3/paper16.pdf(Windows Server 2008 R2 Hyper-V Server Virtualization)
        - microkernel-based hypervisor 
        - lies above the hardware under the os
        - windows driver stack is embedded in the management os (parent partition)
        - driver compatible with the os can be embedded in the virtualization platform
        - I/O opperations are communications between guest os and management os vis VMBus
        - 
- Sysprep
- WinRM vs WindowsDirect (Powershell WindowsDirect)
Ziel:
- Automatisierung Servererstellung und Konfiguration (Chambionic)
    - Testbenutzer
    - adminbenutzer
    - lokaler admin
    - GPOs
    - Freigaben
    - Datev vorbereitungen (ordner zugriffsrechte)
- zeitersparnis durch skriptgesteuerte Erstellung
- umgehung nerviges durchklicken durch gui elemente
- unn√∂tiges eingeben von einzelnen daten umgehen
- zeitersparnis bei der installation von windows da template

Durchf√ºhrung:
- VHD(X) vorbereiten
    - Win Server 2025 iso runterladen
    - VM erstellen mit der iso als boot option
    - windows installieren, wie gewohnt (Windows Server 2025 Evaluation Datacenter [Desktopdarstellung])
    - beim festlegen des Adminpasswortes Strg+Shift+F3 -> start in den audit modus
    - unattend.xml unter C:\ ablegen (unattend.xml aus dem ordner "Serverpreparations")
    - sysprep √ºber admin cmd starten mit sysprep /oobe /generalize /shutdown /unattned:filepath
    - vm nicht neustarten!!!
    - vhd(x) der vm in ordner "Serverpreparations" speichern unter dem namen Serverprep.vhdx
- Skript starten
    GUI
    - Abfrage des Speicherortes der zu erstellenden VM
    - Abfrage des Speicherortes der zu importierenden gpo, zu kopierenden vhdx,xml fs rollen installation, xml f√ºr die gpo
    - Abfrage der Daten wie Kundenname, OU name, Domain name, NetBios name, Server Ip addressen, passw√∂rter f√ºr drms, test user, admin user, standard admin
    - Abfrage des zu verwendenden hyper v switch (netzwerkschnittstelle) 
    - Abfrage der anzahl der kerne f√ºr die VMs
    - Abfrage zur RAM Nutzung der VMs
    Skript
        - Aufteilung in Ordner 
        - Main.ps1 ist, wie der Name schon sagt, das Main Skript zum ausf√ºhren der Befehle und Skripte 
    - Ordner ActiveDirectoryHandling
        - ADUserGroups -> Create 2 Users and a few standard groups -> puts users into groups
        - OrganizationalUnitStructure -> Create OUs and move severs to correct OU
        - RegistryGroupPolicies -> Create Registry based Grouppolicies and import changed gpo via xml
    - Ordner FileHandling
        - DirectoryPreparations -> initialising a new drive to the fs vm and creating directorys to later share in the network
        - FilehandlingFunctions -> Create file structure, remove sensitive files needed to configure win installation, copy files to VMs
        - Permissions -> handle directory permissions (set access permissions to different adgroups)
    - Ordner VMhandling
        - ChangeIpRenameDc -> disable ipv6, rename Computer and set static ipv4
        - ChangeIpRenameTs -> disable ipv6, rename Computer and set static ipv4
        - VmHandlingFunctions -> ckeck redyness of vm, change vm rescressources, active scripts and set static mac to networkadapter 
    - Ordner UserInterfaceFunctions
        - all userinterface functions to get information from the user
    
- Fehler oder Sonstiges
- Verbesserungen/Erweiterungen/Ideen
    - 


    - h√§ndisch sind das von unerfahrenen nutzern ca 2h und von erfahrenen nutzern zwischen 1:15 und 1:30
    - auf altem testserver 40 min bestzeit bei gro√üer hitze bis zu 1h

Vorgehensweise:


\section{Projektidee und Ausgangssituation}

Die Idee zu diesem Projekt entstand aus der praktischen Arbeit im Bereich Windows-Server-Administration, in dem nahezu ausschlie√ülich mit Windows Server und Hyper-V gearbeitet wird.
In der bisherigen Vorgehensweise erfolgt die Erstellung neuer virtueller Maschinen (VMs) in einem Failover-Cluster (Hyper-V) vollst√§ndig manuell ‚Äì beginnend bei der VM-Anlage bis hin zur vollst√§ndigen Konfiguration des Betriebssystems und der ben√∂tigten Rollen.
Ein typisches Szenario tritt auf, wenn ein neuer Kunde im Rechenzentrum eingerichtet wird und in der Standardkonfiguration einen Dom√§nencontroller (DC), einen Dateiserver (FS) sowie einen Terminalserver (TS) erh√§lt.
In diesem Fall m√ºssen drei VMs erstellt und jeweils mit Windows Server installiert werden.
Bei kleineren Kunden kann es vorkommen, dass nur eine oder zwei VMs eingesetzt werden, jedoch wird in dieser Arbeit der Drei-VM-Ansatz betrachtet.
Diese Trennung der Rollen hat den Vorteil einer klaren Aufgabenverteilung, einer besseren √úbersicht und einer optimierten Lastverteilung zwischen den Systemen.
Die manuelle Einrichtung umfasst zahlreiche wiederkehrende Arbeitsschritte.
Auf dem Dateiserver werden Festplatten f√ºr den Speicherplatz angebunden, Ordnerstrukturen angelegt, Freigaben erstellt und NTFS-Berechtigungen vergeben.
Auf dem Terminalserver erfolgt die Installation und Konfiguration der Remotedesktopdienste, wobei im betrachteten Szenario eine sitzungsbasierte Bereitstellung umgesetzt wird.
Dies umfasst die Installation der ben√∂tigten Rollenkomponenten wie Connection Broker, Lizenzserver und Session Host.
Zus√§tzlich wird eine Session Collection f√ºr den Kunden angelegt und einer Active-Directory-Gruppe zugewiesen, die f√ºr den Zugriff per Remote Desktop autorisiert ist.
Die Lizenzierung muss dabei der geplanten Benutzeranzahl entsprechen.
Eine h√§ufig genutzte Ausnahme stellt die DATEV-Anwendung dar, die in vielen Kundenszenarien eingesetzt wird.
Diese wird aus technischen Gr√ºnden meist auf dem Dateiserver installiert, kann jedoch bei gr√∂√üeren Anforderungen auch auf einer dedizierten VM betrieben werden, da sie SQL-Datenbanken mitbringt und entsprechende Ressourcen ben√∂tigt.
Die Aktualisierung von DATEV erfordert eine koordinierte Vorgehensweise auf allen beteiligten Systemen und kann zu tempor√§ren Verbindungsunterbrechungen f√ºhren.
Der Dom√§nencontroller nimmt in diesem Aufbau eine zentrale Rolle ein, da er Benutzer, Gruppen und Gruppenrichtlinien f√ºr alle Systeme der Dom√§ne bereitstellt und verwaltet.
Erst nach seiner vollst√§ndigen Einrichtung k√∂nnen die anderen VMs der Dom√§ne beitreten, sodass Zugriffsrechte und Gruppenrichtlinien wie vorgesehen greifen.
Zudem bietet er die M√∂glichkeit, organisatorische Einheiten (OUs) anzulegen, um die Verwaltung von Computern, Servern und Benutzern zu strukturieren.

Die bisherige manuelle Vorgehensweise erfordert eine Vielzahl von Einzelschritten, darunter: Vergabe statischer IP-Adressen, Umbenennung der Rechner, Einbindung zus√§tzlicher Festplatten, Erstellung von Standard-Benutzern und -Gruppen, Konfiguration von Gruppenrichtlinien sowie Vergabe und Freigabe von Ordnerberechtigungen. Zwar k√∂nnen Gruppenrichtlinien importiert werden, jedoch m√ºssen deren Sicherheitskennungen (SIDs) an die neue Dom√§ne angepasst werden, um die korrekte Funktionsweise sicherzustellen.

Das im Rahmen dieser Arbeit entwickelte PowerShell-Skript automatisiert gro√üe Teile dieser wiederkehrenden Aufgaben. Der Benutzer muss nicht mehr durch zahlreiche grafische Dialoge navigieren oder auf manuelle Zwischenschritte warten. Der Automatisierungsgrad ist bewusst so gestaltet, dass nach einer einmaligen Vorbereitung eines Windows-Server-Templates alle weiteren Konfigurationsschritte skriptgesteuert erfolgen k√∂nnen. Das Skript erstellt und konfiguriert drei VMs (DC, FS, TS), richtet die grundlegenden Rollen ein, erstellt Standard-Benutzer und -Gruppen, legt Ordnerstrukturen an, vergibt NTFS-Berechtigungen, setzt statische IP-Adressen und vergibt Computernamen. Das Ergebnis sind einsatzbereite VMs, die lediglich noch aktiviert und im Fall des Terminalservers mit einem Lizenzserver f√ºr Remotedesktop-Sitzungen verbunden werden m√ºssen.

F√ºr die Vorbereitung wird zun√§chst eine VM mit Windows Server installiert und mithilfe des Windows-eigenen Sysprep-Tools generalisiert. Hierf√ºr wird eine vorgefertigte Antwortdatei (\texttt{unattend.xml}) verwendet, die vor der Generalisierung in das System kopiert wird. Nach dem Start im Audit-Modus (√ºber \texttt{Strg + Umschalt + F3}) und dem Platzieren der Antwortdatei im Verzeichnis \texttt{C:\textbackslash Windows\textbackslash System32\textbackslash Sysprep} kann die Generalisierung √ºber den Befehl
\begin{verbatim}
sysprep.exe /oobe /shutdown /generalize /unattend:C:\Windows\System32\Sysprep\unattend.xml
\end{verbatim}
durchgef√ºhrt werden. Die resultierende VHDX-Datei (\texttt{Serverprep.vhdx}) dient als Template f√ºr die automatisierte Erstellung der zuk√ºnftigen VMs.
---

\section*{Weitere technische Erkenntnisse}

W√§hrend der Entwicklung und Umsetzung des Automatisierungsskripts f√ºr Hyper-V traten eine Vielzahl technischer Besonderheiten und Fallstricke auf, die bei zuk√ºnftigen Projekten ber√ºcksichtigt werden sollten. Eine grundlegende Voraussetzung f√ºr bestimmte Aktionen, wie beispielsweise den Dom√§nenbeitritt, ist die Verwendung eindeutiger SIDs. Dies wurde durch den Einsatz von \texttt{sysprep} in Verbindung mit einer funktionierenden Antwortdatei sichergestellt. Dabei zeigte sich, dass die Antwortdatei strikt in der Reihenfolge von oben nach unten abgearbeitet wird, weshalb der \texttt{OOBE}-Abschnitt m√∂glichst fr√ºh platziert werden sollte.  

Im Bereich der Skripterstellung mit PowerShell war besonders bei der Arbeit mit GUIs und Benutzerinteraktionen Aufmerksamkeit erforderlich. So erwies es sich als sinnvoll, beim Aufbau einer RAM-Auswahl Integer-Werte in Byte-Form anzugeben, da Strings in Arrays nicht zuverl√§ssig verarbeitet wurden. Das R√ºckgabeverhalten wurde √ºber \texttt{return} angepasst, um korrekte Werte zu liefern. Au√üerdem zeigte sich, dass in PowerShell die √úberpr√ºfung auf \texttt{NULL} konsistent mit der Schreibweise \texttt{NULL -eq \$Variable} erfolgen sollte, um logische Fehler -- insbesondere bei Array-Pr√ºfungen -- zu vermeiden.  

GUI-Fenster verhielten sich in Bezug auf die Anzeige im Vordergrund nicht immer wie erwartet, selbst wenn die Eigenschaft \texttt{TopMost} gesetzt war. Dieses Problem wurde durch die Definition eines Mutterfensters und die gezielte Anzeige untergeordneter Fenster mit \texttt{.Add\_Shown()} gel√∂st. Passworteingaben lie√üen sich in der GUI zwar ausblenden, mussten jedoch f√ºr die weitere Verarbeitung mittels \texttt{ConvertTo-SecureString -PlainText} in ein SecureString-Format konvertiert werden. Beim Ausw√§hlen von Verzeichnissen war zu beachten, dass der Pfad √ºber die Eigenschaft \texttt{InitialDirectory} und nicht \texttt{RootFolder} festgelegt werden muss.  

F√ºr die Eingabevalidierung, beispielsweise bei IP-Adressen, bot sich die Nutzung regul√§rer Ausdr√ºcke wie \texttt{"[0-9]+\textbackslash.[0-9]+\textbackslash.[0-9]+\textbackslash.[0-9]+"} an. Variablen, die innerhalb von Remote-Jobs oder Sessions genutzt werden, mussten mit dem Pr√§fix \texttt{Using:} √ºbergeben werden -- auch dann, wenn sie zuvor global deklariert wurden. Innerhalb von Strings war eine Variablenersetzung nur mit der Schreibweise \texttt{\$(Variable)} m√∂glich. Bei Abfragen, die einen String erfordern, erwies sich die Verwendung des Parameters \texttt{-ExpandProperty} als notwendig, um Objektr√ºckgaben zu vermeiden.  

Das Ausf√ºhren von Befehlen mit dem Parameter \texttt{-AsJob} startete Prozesse im Hintergrund, was problematisch sein konnte, wenn das Ergebnis sofort ben√∂tigt wurde. In solchen F√§llen war es erforderlich, den Job aktiv zu √ºberwachen, das Ende der Ausf√ºhrung abzuwarten und anschlie√üend den Job zu entfernen. Beim Einsatz von \texttt{Invoke-Command} konnte entweder direkt mit VM-Namen oder mit zuvor erstellten Sessions gearbeitet werden; letztere mussten nach Abschluss wieder geschlossen werden. Um Anmeldevorg√§nge zu vermeiden, konnten Anmeldeinformationen als \texttt{PSCredential}-Objekte hinterlegt werden. Diese wurden √ºber \texttt{New-Object} erstellt, wobei das Passwort als SecureString abgefragt und zusammen mit dem Benutzernamen in einer Variablen gespeichert wurde.  

Vor der Ausf√ºhrung des Skripts wurde gepr√ºft, ob es in einer administrativen Sitzung lief. Falls nicht, wurde es √ºber \texttt{Start-Process} mit dem Verb \texttt{RunAs} neu gestartet. F√ºr eine einheitliche Protokollierung wurde eine Log-Funktion erstellt, die Zeitstempel im Format \texttt{"[dd/MM/yy HH:mm:ss]"} generierte. Nicht ben√∂tigte Ausgaben wurden konsequent mit \texttt{| Out-Null} unterdr√ºckt.  

Netzwerkanpassungen innerhalb von Windows-VMs erfolgten mit \texttt{New-NetIPAddress} anstelle von \texttt{Set-NetIPAddress}. Um Dateien vom Hyper-V-Host auf eine VM zu √ºbertragen, musste die Gastdienstschnittstelle aktiviert werden, was √ºber \texttt{Enable-VMIntegrationService} m√∂glich war. Anschlie√üend konnte der Kopiervorgang mit \texttt{Copy-VMFile} durchgef√ºhrt werden, wobei Systempfade nur indirekt beschreibbar waren.  

Die Installation bestimmter Serverrollen, wie des Dateiservers, war nur √ºber XML-basierte Konfigurationen m√∂glich. Remote Desktop Services (RDS) konnten vom Dom√§nencontroller auf den Terminalserver installiert werden, wobei zus√§tzliche Konfigurationen -- etwa Session Collections, RDS-Lizenzierung und Neustarts des Verwaltungsdienstes -- direkt auf dem TS erfolgten.  

Weitere Besonderheiten betrafen die Handhabung von Strings, Hash-Tabellen und VM-Eigenschaften: Beim Splitten eines Strings am Punkt musste der Punkt mit \texttt{"\textbackslash."} escaped werden. VMs konnten vollst√§ndig aus Hash-Tabellen heraus erstellt werden, wobei CPU-Anpassungen erst nach der Erstellung und MAC-Adress√§nderungen nur nach dem ersten Start m√∂glich waren. Neue virtuelle Festplatten wurden per \texttt{Add-VMHardDiskDrive} angebunden, anschlie√üend online geschaltet, benannt, mit einem Laufwerksbuchstaben versehen und formatiert.  

Passw√∂rter von Active-Directory-Konten lie√üen sich nicht ohne Weiteres zur√ºcksetzen, w√§hrend lokale Passw√∂rter per Remote- oder PowerShell-Direct-Zugriff problemlos ge√§ndert werden konnten. Bestimmte Installationsfehlermeldungen bei RDS lie√üen sich m√∂glicherweise auf fehlende Lizenzserverkonfigurationen zur√ºckf√ºhren.

---

Skript:


Vorgehensweise:
Im Rahmen der Skripterstellung wurde zun√§chst ein VM-Template erstellt. Diese Einrichtung erfolgt einmalig und setzt die Installation eines Windows-Server-Betriebssystems voraus. Ein wesentlicher Bestandteil dieses Schrittes war die Erstellung einer Antwortdatei (Unattend-XML), die im sp√§teren Prozess die automatisierte Erstkonfiguration erm√∂glicht.

Zur Generierung der Antwortdatei wurde die Windows-Server-ISO eingebunden und mit dem Windows System Image Manager das darin enthaltene Abbild (install.wim) geladen. Anschlie√üend wurde die Zieledition ‚ÄûServer Standard‚Äú ausgew√§hlt, da diese als Grundlage f√ºr die Kunden-VMs vorgesehen ist. Vor der Definition der eigentlichen Antwortdatei wurde eine Katalogdatei erzeugt. Innerhalb der Antwortdatei wurden die relevanten Konfigurationsoptionen integriert, insbesondere im Bereich Microsoft-Windows-Shell-Setup. Dabei lag der Fokus auf dem Abschnitt OOBE, um die Ersteinrichtung zu automatisieren und zus√§tzliche Benutzerkonten anzulegen.

Nach Erstellung der XML-Datei wurde die Installation so angepasst, dass das Administrator-Passwort √ºber den Audit-Modus (STRG+Shift+F3) definiert werden konnte. Dies erm√∂glichte individuelle Anpassungen sowie die Absicherung des lokalen Administratorkontos. F√ºr das Skript war ausschlie√ülich relevant, dass die Passwortvergabe gew√§hrleistet, ein zus√§tzlicher lokaler Administrator angelegt und Einrichtungsdialoge durch die XML-Datei √ºbersprungen wurden. Erg√§nzend wurde das Tastaturlayout auf Deutsch gesetzt.

Die vollst√§ndige XML-Datei wurde im Verzeichnis des Windows-Systemvorbereitungstools (Sysprep, i.d.R. unter C:\Windows\System32\Sysprep) gespeichert. Anschlie√üend erfolgte die Ausf√ºhrung von Sysprep mit den Parametern /oobe, /generalize, /shutdown sowie /unattend:(Pfad zur XML-Datei). Dadurch wurde die Windows-Installation generalisiert und von der spezifischen VM-Umgebung entkoppelt. Die einmalige Erstellung und Konfiguration beanspruchte auf einem leistungsf√§higen System etwa f√ºnf bis zehn Minuten.

Durch die Generalisierung der Windows-Installation wird erreicht, dass die virtuelle Festplatte (VHD/X) einer erstellten VM kopiert und mehrfach wiederverwendet werden kann, ohne dass Konflikte zwischen den Sicherheits-IDs (SIDs) der Administratorbenutzer verschiedener VMs auftreten. Entscheidend ist hierbei, dass die betreffende VM nach der Generalisierung nicht erneut gestartet wird, bevor die VHD(X)-Datei kopiert wurde, da ansonsten die Generalisierung ihre G√ºltigkeit verliert.

Im n√§chsten Schritt erfolgte die Erstellung von VMs mithilfe von PowerShell. Der grundlegende Ablauf entspricht dabei den Prozessen, die auch aus anderen Virtualisierungsl√∂sungen bekannt sind: Jedem virtuellen System werden ein Name, ein Speicherort, Arbeitsspeicher, CPU-Kerne, ein Netzwerkadapter sowie eine Bootfestplatte zugewiesen. Da bereits eine vorbereitete VHDX-Datei f√ºr die Bootpartition vorliegt, konnte dieser Teil √ºbersprungen werden. F√ºr den Fileserver wurde zus√§tzlich eine separate Festplatte eingerichtet, die der Speicherung der Nutzerdaten dient und entsprechend in das System eingebunden wird. Die Konfiguration √ºber PowerShell erforderte somit lediglich Schritte, die auch √ºber die grafische Oberfl√§che ausgef√ºhrt werden k√∂nnten.

Das vorbereitete VHD(X)-Template wird an den vorgesehenen Speicherort kopiert, anschlie√üend erfolgt die Zuweisung von Ressourcen wie Arbeitsspeicher und Prozessoranzahl. Nach Abschluss dieser Konfiguration ist die VM startbereit und kann f√ºr Tests verwendet werden. F√ºr jede neue VM wird dieser Prozess identisch durchgef√ºhrt, wodurch sich manuelle Vorgehensweisen mit den PowerShell-basierten Methoden vergleichen lassen.

Vor dem Einstieg in weitere Schritte war eine zus√§tzliche Anpassung hinsichtlich der Netzwerkadapter erforderlich. Da die Systeme √ºber TeamViewer verwaltet werden, musste f√ºr den Netzwerkadapter jeder VM eine statische MAC-Adresse vergeben werden. Dies verhindert, dass die Systeme aus der Ger√§teliste in TeamViewer verschwinden. Um die MAC-Adresse zuweisen zu k√∂nnen, wird die VM einmalig gestartet, sodass Windows eine tempor√§re Adresse generiert. Anschlie√üend wird die Maschine heruntergefahren und in Hyper-V die MAC-Adresse auf statisch gesetzt. Danach kann der regul√§re Arbeitsablauf fortgesetzt werden.

Perfekt, ich sehe worauf du hinauswillst üëç. Ich habe auch diesen Text so umformuliert, dass er wissenschaftlich-n√ºchtern, aus der Perspektive einer Prozessbeschreibung wirkt, gleichzeitig aber weiterhin dein Vorgehen beschreibt. Das Ziel ist, dass es wie ein koh√§renter Abschnitt in einer wissenschaftlichen Arbeit klingt, nicht wie eine Schritt-f√ºr-Schritt-Anleitung.
Wissenschaftlich √ºberarbeitete Fassung

Zur Verwaltung der Kunden-VMs wurde eine einheitliche Ordnerstruktur implementiert. Hierf√ºr wurde ein eigenes Skript (FilehandlingFunctions) entwickelt, das f√ºr jeden Kunden automatisch identische Verzeichnisse anlegt, wobei die Struktur jeweils unter dem individuellen Kundennamen eingetragen wird. Innerhalb dieser Hierarchie werden die vorbereiteten VHD(X)-Dateien aus dem zentralen Vorbereitungsverzeichnis in die entsprechenden Kundenordner kopiert. Vor der Erstellung √ºberpr√ºft das Skript, ob die betreffende Struktur bereits vorhanden ist, um redundante Duplikate zu vermeiden. Die Umsetzung basiert auf einfachem File Handling, wobei neue Verzeichnisse mit dem PowerShell-Befehl New-Item erzeugt werden.

Neben der Verzeichnisstruktur wird f√ºr jeden Kunden zus√§tzlich ein Logfile eingerichtet. Dieses erm√∂glicht sowohl die Nachverfolgung des Skriptablaufs als auch die Identifikation m√∂glicher Fehlerquellen oder Prozessunterbrechungen. Da das VHD(X)-Template f√ºr die VM-Erstellung standardm√§√üig die Datei unattend.xml enth√§lt, in der Administratorpassw√∂rter hinterlegt sind, entsteht ein nicht zu vernachl√§ssigendes Sicherheitsrisiko. Um dies zu vermeiden, wird die unattend.xml nach erfolgreicher Erstellung der Kundenordner sowie der zugeh√∂rigen VM mithilfe einer im Skript implementierten Funktion wieder gel√∂scht.

Bei der Entwicklung des Skripts wurde zudem der Umgang mit Variablen und deren G√ºltigkeitsbereichen ber√ºcksichtigt. Variablen aus dem Hauptskript k√∂nnen zwar in ein Unterskript √ºbernommen werden, m√ºssen dann jedoch mit dem Pr√§fix Using gekennzeichnet werden. Effizienter ist es, Funktionen mit Parametern zu verwenden, wodurch sich das Vorgehen strukturell mit der Trennung von Header- und Code-Dateien in C/C++ vergleichen l√§sst ‚Äì allerdings ohne die Existenz tats√§chlicher Header-Dateien. Funktionen werden √ºber ein separates Skript eingebunden, sodass sie entweder lokal wiederverwendet oder per Invoke-Command auf einem Zielsystem remote ausgef√ºhrt werden k√∂nnen.

Mithilfe von PowerShell Direct ist es m√∂glich, innerhalb von Hyper-V direkt Befehle in den VMs auszuf√ºhren, ohne auf Netzwerkverbindungen angewiesen zu sein. Alternativ k√∂nnen Befehle √ºber das Netzwerk mittels Windows Remote Management (WinRM) ausgef√ºhrt werden, wobei jedoch die Problematik des sogenannten Kerberos Double Hop auftreten kann. Vor der Installation von Rollen ist es notwendig, den VMs statische IP-Adressen zuzuweisen und sowohl dem Fileserver als auch dem Terminalserver den Domain Controller als DNS-Server einzutragen. Dar√ºber hinaus erfolgt eine Anpassung der Computernamen zur eindeutigen Identifikation. F√ºr diesen Zweck wurden spezifische kleine Skripte (ChangeIpRenameTs bzw. ChangeIpRenameDc) entwickelt, die die Konfiguration automatisieren.

Die Einrichtung des Domain Controllers basiert ebenfalls auf PowerShell. Bei einer manuellen Installation l√§sst sich vor der Heraufstufung ein Skript generieren, das die durchgef√ºhrten Arbeitsschritte abbildet. Dieses Vorgehen bietet wertvolle Einblicke in die notwendigen Befehle, zus√§tzlich stehen umfassende Informationen in der offiziellen Microsoft-Dokumentation zur Verf√ºgung. F√ºr die automatisierte Konfiguration wurde eine Hashmap erstellt, die alle erforderlichen Parameter wie Dom√§nenname, NetBIOS-Name, DSRM-Passwort sowie Pfade f√ºr System- und Logdateien enth√§lt. Anschlie√üend wurde die ben√∂tigte Rolle installiert und der Domain Controller mittels Install-ADDSForest heraufgestuft. Nach einem Neustart stand damit die Grundkonfiguration zur Verf√ºgung. Vor dem Neustart wurde zudem der Google-DNS-Server (8.8.8.8) in die Liste der Weiterleitungen aufgenommen.

Im Gegensatz dazu gestaltet sich die Installation der Fileserver-Rolle komplexer, da es sich hierbei um eine Unterrolle handelt. Eine direkte Konfiguration √ºber PowerShell ist nur eingeschr√§nkt m√∂glich. Stattdessen k√∂nnen jedoch XML-Dateien verwendet werden, die automatisch aus einer manuellen Installation generiert werden. Da die Rolleninstallation auf allen Systemen identisch erfolgt und keine zus√§tzlichen spezifischen Einstellungen erforderlich sind, wurde dieses Vorgehen als praktikable L√∂sung genutzt.

F√ºr die erfolgreiche Automatisierung war es erforderlich, dass bestimmte XML- und Konfigurationsdateien auf den Zielsystemen verf√ºgbar sind. Um dies zu erm√∂glichen, musste die Gastdienstschnittstelle innerhalb der VMs aktiviert werden, wodurch sich Dateien direkt vom Hostsystem in die Gastsysteme √ºbertragen lassen. Vor dem eigentlichen Transfer wurde in jeder VM ein Ordner angelegt, in den die relevanten Dateien kopiert werden. F√ºr den Domain Controller waren dies Gruppenrichtlinien-Dateien, w√§hrend f√ºr den Fileserver die Installations-XML der entsprechenden Rolle vorgesehen war. Die Installation der Fileserver-Rolle erfolgt gemeinsam mit der Konfiguration einer statischen IP-Adresse, da diese Rolle unabh√§ngig vom Domain Controller eingerichtet wird (DeployFileServerRole).

Zum betrachteten Zeitpunkt standen bereits drei VMs zur Verf√ºgung, von denen zwei mit den vorgesehenen Rollen ausgestattet waren und ein funktionsf√§higer Domain Controller bereitgestellt war. Der darauffolgende Schritt bestand darin, die verbleibenden Server in die Dom√§ne aufzunehmen, nachdem der Domain Controller vollst√§ndig gestartet war. Dies konnte mit einer dedizierten PowerShell-Funktion erreicht werden, die unter Verwendung von Invoke-Command den Dom√§nenbeitritt initiiert.

Im Zuge der Experimente mit den VM-Templates zeigte sich jedoch, dass Fehler in der Generalisierung (z. B. durch fehlerhafte Unattend-Dateien) dazu f√ºhren k√∂nnen, dass lokale Administratoren auf unterschiedlichen Systemen identische Sicherheits-IDs (SIDs) erhalten. In diesem Fall schl√§gt der Dom√§nenbeitritt fehl. Daher ist bei der Erstellung der Unattend-Datei besondere Sorgfalt erforderlich. Die √úberpr√ºfung der SIDs kann nach der VM-Erstellung √ºber den Befehl Get-LocalUser -Name Administrator | FL erfolgen. Werden identische SIDs festgestellt, ist davon auszugehen, dass die Generalisierung mit Sysprep nicht korrekt durchgef√ºhrt wurde, was wiederum zum Abbruch des Skripts f√ºhren w√ºrde.

Nach erfolgreichem Dom√§nenbeitritt der Systeme folgte die Vorbereitung des Fileservers. Hierzu wurde die zus√§tzliche Festplatte zun√§chst online geschaltet und mit dem Partitionsstil GPT initialisiert. Anschlie√üend wurde die gesamte Speicherkapazit√§t in einer Partition zusammengefasst, die mit einem Laufwerksbuchstaben (im Skript: D:) und einer eindeutigen Bezeichnung (‚ÄûDaten‚Äú) versehen wurde. In diesem Verzeichnis wurden standardisierte Basisordner angelegt, die sp√§ter als Grundlage f√ºr Freigaben dienen. Da Freigaben mit bestimmten Active-Directory-Gruppen verkn√ºpft sind, war zuvor eine grundlegende AD-Struktur zu etablieren.

Die erstellte Active-Directory-Struktur umfasste exemplarische Benutzerkonten (z. B. einen Testbenutzer und einen Administrationsaccount), mehrere Standardgruppen (beispielsweise Scan_LW, Datevuser, Daten_LW, GF f√ºr Gesch√§ftsf√ºhrung) sowie Organisationseinheiten zur strukturierten Trennung von Benutzern, Gruppen und Computern. Die Benutzer wurden in Form von Hashmaps angelegt, w√§hrend Gruppen √ºber den Befehl New-ADGroup erstellt wurden. Im Anschluss wurden die Benutzer den entsprechenden Gruppen zugeordnet.

Zur Grundstruktur des Active Directory geh√∂ren auch Standardrichtlinien, etwa f√ºr Netzlaufwerke, Remotedesktop-Einstellungen, Einschr√§nkungen der Eingabeaufforderung und Skriptausf√ºhrung sowie das Deaktivieren von ‚ÄûNew Outlook‚Äú. Da viele dieser Gruppenrichtlinien auf Registry-Eintr√§gen basieren, k√∂nnen sie mithilfe von Hashmaps umgesetzt werden. Die ben√∂tigten Registry-Keys lassen sich entweder durch das Auslesen bestehender Richtlinien √ºber Get-GPPrefRegistryValue oder durch Dokumentationen im Internet identifizieren.

Komplexer gestaltet sich die Abbildung von Netzlaufwerken. Die manuelle Konfiguration eines Netzlaufwerks f√ºhrt zu einer Vielzahl an Registry-Eintr√§gen. Werden diese als Grundlage f√ºr eine neue Gruppenrichtlinie √ºbernommen, schl√§gt die Umsetzung h√§ufig fehl, sodass die Laufwerke nicht im Explorer angezeigt werden. Dadurch werden sie f√ºr Endnutzer unbrauchbar. Um dieses Problem zu umgehen, wurde eine bereits funktionierende Gruppenrichtlinie mit den Netzlaufwerken aus einem bestehenden System exportiert, in die VM des Domain Controllers √ºbertragen, an die SID der neuen Dom√§ne angepasst und anschlie√üend importiert.

Die importierten Gruppenrichtlinien (GPOs) verhalten sich nach der Anpassung der SIDs wie manuell erstellte Richtlinien. Ein direkter Eingriff in einzelne Registry-Eintr√§ge ist damit nicht erforderlich, da die XML-Dateien der GPOs in einer Schleife verarbeitet und die enthaltenen Gruppen angepasst werden k√∂nnen. Mit Abschluss dieser Schritte stand das Grundger√ºst des Active Directory bereit, womit lediglich noch wenige Arbeitsschritte bis zur Fertigstellung des Automatisierungsskripts zur Serverstruktur erforderlich waren.

Um den Zugriff auf die Verzeichnisse des Terminalservers zu erm√∂glichen, wurden die Ordner zun√§chst freigegeben und mit den notwendigen Berechtigungen versehen. Die Freigabe konnte mit dem Befehl New-SmbShare umgesetzt werden, wobei mithilfe von Hashmaps und Schleifen Freigabename, Pfad und Berechtigungen automatisiert zugewiesen wurden. Im Anschluss wurden die NTFS-Berechtigungen auf Verzeichnis- und Dateiebene konfiguriert. Hierf√ºr wurden die bestehenden Rechte eines Verzeichnisses zun√§chst mit Get-Acl in einer Variablen gespeichert, anschlie√üend √ºber eine Hashmap neue Eintr√§ge definiert (Benutzer bzw. Gruppe, Berechtigungsumfang sowie Anwendungsbereich: Ordner, Unterordner und Dateien). Diese wurden in ein neues ACL-Objekt √ºberf√ºhrt und mit Set-Acl auf das jeweilige Verzeichnis angewendet.

Ein Problem dieser Vorgehensweise besteht darin, dass Rechte jeweils nur f√ºr einen Ordner und eine Gruppe gleichzeitig gesetzt werden k√∂nnen. Der Versuch, mehrere Eintr√§ge parallel zu √ºbernehmen, f√ºhrte entweder zu fehlerhaften Berechtigungen oder zu fehlenden Fehlermeldungen, sodass die Rechtevergabe stets einzeln vorgenommen werden musste. Nach der Umsetzung der Freigaben und NTFS-Berechtigungen verblieb als letzter Bestandteil die Einrichtung des Terminalservers.

Die Installation der dazugeh√∂rigen Rollen konnte nicht vollst√§ndig √ºber PowerShell-Kommandos innerhalb des Gastesystems erfolgen. Stattdessen wurden die Rollen mithilfe von PowerShell Direct √ºber den Hyper-V-Host remote in die VM installiert und anschlie√üend konfiguriert. Damit konnte eine funktionsf√§hige Terminalserver-Umgebung bereitgestellt werden, wenngleich die Lizenzierungskonfiguration nicht Teil des Skripts war. Auch ohne diese Konfiguration ist eine Anmeldung mittels Remotedesktop f√ºr einzelne Benutzer m√∂glich, wodurch Kernfunktionen des Terminalservers zur Verf√ºgung stehen.

Zum Abschluss wurden s√§mtliche VMs einmalig neu gestartet, um einen einheitlichen Betriebszustand herzustellen und alle Konfigurationen sowie √Ñnderungen, die einen Neustart erforderten, g√ºltig zu machen. Lediglich beim Terminalserver besteht eine geringe Wahrscheinlichkeit, dass ein Dienst nach dem Neustart nicht ordnungsgem√§√ü ausgef√ºhrt wird. Da im Anschluss an die Grundkonfiguration jedoch weitere Installationen und Anpassungen erfolgen, wird dieses Restrisiko als vernachl√§ssigbar eingestuft.

---
Test:

\chapter{Testumgebungen}

Zur Validierung des entwickelten Skripts wurden Testdurchl√§ufe in zwei unterschiedlichen Umgebungen durchgef√ºhrt. Dadurch kann die Stabilit√§t und Portabilit√§t der L√∂sung besser eingesch√§tzt werden, da sowohl die eingesetzte Hardware als auch die Software variieren.

\section{Hardware- und Softwarekonfiguration}

\begin{table}[H]
\centering
\caption{Hardware- und Softwarekonfiguration der Testumgebungen}
\label{tab:hardware_config}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Komponente} & \textbf{Testumgebung Zuhause} & \textbf{Testumgebung Server} \ \hline
CPU & AMD Ryzen 7 7800X3D, 8 Kerne / 16 Threads, 4,3--4,5GHz & Intel Xeon E3-1230 v5, 4 Kerne / 8 Threads, 3,7GHz \ \hline
RAM & 32GB DDR5-6000 & 64GB DDR4-2133 (4 $\times$ 16GB) \ \hline
Speicher & NVMe-SSD, 2TB, PCIe 3.0, 3500MB/s Lesen, 3000MB/s Schreiben & SSD-RAID (Fujitsu PRAID EP400i, SCSI-Interface) \ \hline
PowerShell-Version & 7.5.2 (Core Edition) & 5.1 \ \hline
Windows-Version & Windows 11 Pro & Windows Server 2025 Standard \ \hline
\end{tabular}
\end{table}

\section{Virtuelle Maschinen}

Die virtuellen Maschinen wurden in beiden Testumgebungen identisch konfiguriert:

\begin{itemize}
\item \textbf{CPU-Kerne:} 2
\item \textbf{RAM:} 2GB pro VM
\item \textbf{Zus√§tzliche VHDX:} 35MB auf dem File Server
\end{itemize}

\chapter{Testmethodik}

Zur √úberpr√ºfung des entwickelten Skripts wurden mehrere Testdurchl√§ufe auf den beschriebenen Umgebungen durchgef√ºhrt. Ziel war die Validierung der Funktionsf√§higkeit, Stabilit√§t und Ausf√ºhrungsdauer des Automatisierungsprozesses. Der Fokus lag dabei nicht auf einer detaillierten funktionalen Pr√ºfung der konfigurierten Dienste, sondern auf der wiederholbaren und automatisierten Erstellung der virtuellen Maschinen.

\section{Vorgehensweise}

\begin{itemize}
\item Das Skript wurde in beiden Umgebungen jeweils \textbf{f√ºnfmal} ausgef√ºhrt.
\item W√§hrend der Ausf√ºhrung wurde das integrierte Logging verwendet, um die Dauer der Testl√§ufe zu protokollieren.
\item Fehler und Auff√§lligkeiten im Ablauf wurden dokumentiert.
\end{itemize}

\section{Bewertungskriterien}

Die Testdurchl√§ufe wurden anhand folgender Kriterien bewertet:

\begin{itemize}
\item \textbf{Ausf√ºhrungsdauer:} Zeit, die das Skript f√ºr Erstellung und Grundkonfiguration der VMs ben√∂tigt.
\item \textbf{Stabilit√§t:} F√§higkeit des Skripts, aufeinanderfolgende Durchl√§ufe fehlerfrei zu absolvieren.
\item \textbf{Reproduzierbarkeit:} Konsistenz der Ergebnisse zwischen den Durchl√§ufen und Umgebungen.
\end{itemize}

\section{Zielsetzung}

Die Testmethodik dient prim√§r der Validierung des Automatisierungsprozesses und nicht einer funktionalen √úberpr√ºfung der konfigurierten Rollen und Dienste. Mehrfache Durchl√§ufe erm√∂glichen die Erfassung von Abweichungen in der Ausf√ºhrungsdauer und die Bewertung der Zuverl√§ssigkeit des Skripts.

\chapter{Testergebnisse}

\section{Testumgebung Zuhause}

\begin{table}[h!]
\centering
\caption{Zeit√ºbersicht der Testdurchl√§ufe ‚Äì Home (relative Zeiten)}
\label{tab:home_times}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
\textbf{Schritt} & \textbf{Log 1} & \textbf{Log 2} & \textbf{Log 3} & \textbf{Log 4} & \textbf{Log 5} \ \hline
Start & 15:44:20 & 17:30:04 & 18:16:06 & 18:47:11 & 20:53:45 \
Kopieren fertig & 0:00:26 & 0:00:31 & 0:00:32 & 0:00:31 & 0:00:32 \
VMs erstellt & 0:00:30 & 0:00:36 & 0:00:36 & 0:00:34 & 0:00:36 \
VMs angepasst & 0:00:31 & 0:00:36 & 0:00:36 & 0:00:35 & 0:00:37 \
VMs gestartet & 0:00:34 & 0:00:39 & 0:00:39 & 0:00:37 & 0:00:40 \
Windows initialisierung fertig & 0:01:13 & 0:01:34 & 0:01:30 & 0:01:28 & 0:01:32 \
... & ... & ... & ... & ... & ... \
\textbf{Gesamtzeit} & 0:18:40 & 0:18:43 & 0:19:10 & 0:18:33 & 0:19:04 \ \hline
\end{tabular}
\end{table}

\section{Testumgebung Server}

\begin{table}[H]
\centering
\caption{Zeit√ºbersicht der Testdurchl√§ufe ‚Äì Server (relative Zeiten)}
\label{tab:server_times}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
\textbf{Schritt} & \textbf{Log 1} & \textbf{Log 2} & \textbf{Log 3} & \textbf{Log 4} & \textbf{Log 5} \ \hline
Start & 09:24:01 & 08:46:27 & 09:42:02 & 11:24:36 & 12:37:53 \
Kopieren fertig & 0:06:02 & 0:06:03 & 0:04:53 & 0:04:53 & 0:04:52 \
VMs erstellt & 0:06:15 & 0:06:14 & 0:05:03 & 0:05:04 & 0:05:04 \
VMs angepasst & 0:06:15 & 0:06:14 & 0:05:04 & 0:05:04 & 0:05:04 \
VMs gestartet & 0:06:20 & 0:06:19 & 0:05:09 & 0:05:09 & 0:05:09 \
Windows initialisierung fertig & 0:10:52 & 0:12:12 & 0:09:52 & 0:11:17 & 0:10:21 \
... & ... & ... & ... & ... & ... \
\textbf{Gesamtzeit} & 0:43:11 & 0:43:29 & 1:09:41 & 0:43:08 & 0:41:37 \ \hline
\end{tabular}
\end{table}

\chapter{Fazit und Ausblick}

Im Rahmen dieser Arbeit wurde ein PowerShell-basiertes Automatisierungsskript entwickelt, das die Erstellung und Konfiguration von Windows-basierten virtuellen Maschinen in einer Hyper-V-Umgebung erm√∂glicht.
Die Ergebnisse der durchgef√ºhrten Testdurchl√§ufe best√§tigen die Funktionsf√§higkeit und Stabilit√§t des Skripts. Die Tests erfolgten in zwei unterschiedlichen Umgebungen: einer leistungsstarken Desktop-Konfiguration mit AMD Ryzen 7 7800X3D, 32‚ÄØGB RAM und NVMe-SSD sowie einem Server mit Intel Xeon E3-1230‚ÄØv5, 64‚ÄØGB RAM und SSD-RAID. Die VMs wurden in beiden Umgebungen identisch mit 2 CPU-Kernen, 2‚ÄØGB RAM und einer zus√§tzlichen 35‚ÄØMB VHDX-Datei konfiguriert.

Die Testdurchl√§ufe zeigten, dass die Bereitstellung der Basisumgebung in der Desktop-Umgebung innerhalb von etwa 18 bis 19‚ÄØMinuten abgeschlossen werden konnte. Auf dem Server variierte die Dauer aufgrund der unterschiedlichen Hardware und PowerShell-Version zwischen ca. 41 und 69‚ÄØMinuten, wobei die meisten Durchl√§ufe um 43‚ÄØMinuten lagen. Die Unterschiede erkl√§ren sich vor allem durch die I/O-Leistung des Speichersystems, die CPU-Auslastung und die PowerShell-Version.

W√§hrend der Tests traten lediglich kleinere Fehlermeldungen auf, beispielsweise im Zusammenhang mit der Einrichtung der Session Collection oder gelegentlichen Abbr√ºchen von Remoteverbindungen. Diese hatten jedoch weder in den Testumgebungen mit Dom√§nenanbindung noch im Betrieb mit Testbenutzern sp√ºrbare Auswirkungen auf die Funktionalit√§t. Insgesamt zeigten die mehrfachen Durchl√§ufe eine hohe Reproduzierbarkeit und Stabilit√§t des Skripts.

Trotz des erreichten Funktionsumfangs bestehen mehrere Potenziale f√ºr zuk√ºnftige Verbesserungen. Hierzu z√§hlt die M√∂glichkeit, f√ºr kleinere Kundenumgebungen nur ein oder zwei Server bereitzustellen, wodurch Ressourcen und Zeit eingespart werden k√∂nnten. Eine flexible Anpassung des der virtuellen Maschine zugewiesenen Speichers ‚Äì idealerweise √ºber eine grafische Benutzeroberfl√§che (\textit{GUI}) ‚Äì w√ºrde zudem die Bedienbarkeit und den Einsatzbereich erweitern. Auch die vollst√§ndige Automatisierung zus√§tzlicher Terminalserver-Konfigurationen, wie etwa die Lizenzserver-Einrichtung, k√∂nnte den manuellen Administrationsaufwand weiter reduzieren.

F√ºr den Einsatz in hochverf√ºgbaren Umgebungen w√§re eine Anpassung an Failover-Cluster-Architekturen erforderlich. Dies erfordert die Erweiterung des Skripts um clusterrelevante Rollen und Eigenschaften, da es bislang ausschlie√ülich in Einzelhost-Szenarien getestet wurde. Ein weiteres Optimierungspotenzial liegt in der Abl√∂sung der derzeitigen statischen Wartezeit nach der Installation des Dom√§nencontrollers durch ein dynamisches, ereignisgesteuertes Verfahren, um die Bereitstellungsdauer zu verk√ºrzen und die Professionalit√§t der Umsetzung zu erh√∂hen. Dar√ºber hinaus k√∂nnte die Benutzeranlage durch den Import vordefinierter XML-Dateien automatisiert werden, was die Konsistenz und Wiederholbarkeit der Konfiguration verbessern w√ºrde.

Insgesamt zeigt die Arbeit, dass durch den gezielten Einsatz von PowerShell-Skripten in Verbindung mit Hyper-V eine deutliche Effizienzsteigerung in der Serverbereitstellung erreicht werden kann. Die durchgef√ºhrten Tests auf unterschiedlichen Hardwarekonfigurationen belegen dabei die Flexibilit√§t und Anpassungsf√§higkeit des Skripts. Die skizzierten Verbesserungsans√§tze bieten dar√ºber hinaus ein hohes Potenzial f√ºr zuk√ºnftige Entwicklungen, insbesondere im Hinblick auf Flexibilit√§t, Skalierbarkeit und Integration in komplexere IT-Infrastrukturen.
\newpage

Text:\\

Idee:
Automatisierung einer Serverstruktur in Hyper-V. Dabei wird ber√ºcksichtigt, dass es einen Domain Controller, einen Fileserver und einen Terminalserver gibt. Die Erstellung soll au√üerdem das Anlegen von freigegebenen Ordnern und Gruppenrichtlinien sowie die Einrichtung eines Domain Admins und eines Test Users f√ºr die Firma beinhalten. Zudem soll die Installation von Windows durch ein VM-Template umgangen werden.

Stand in der Firma:
Derzeit wird alles manuell √ºber die GUI in Windows erledigt. Zus√§tzlich wird auf jeder VM Windows separat installiert. Selbst Gruppenrichtlinien, die man per PowerShell erstellen kann, oder das Anlegen von Usern und Gruppen werden √ºber die GUI durchgef√ºhrt. Das ist insbesondere heutzutage unprofessionell, da Windows zahlreiche M√∂glichkeiten zur Automatisierung bietet.

Vorgehensweise:
Der erste Schritt f√ºr das Skript ist die Erstellung eines VM-Templates. Dieses wird einmalig manuell erstellt, und dabei muss Windows Server nur ein einziges Mal installiert werden. Wichtig ist au√üerdem die Erstellung einer Antwortdatei (unattend.xml) im XML-Format. Diese l√§sst sich problemlos mit der ISO von Windows Server und dem Windows-eigenen Windows System Image Manager erzeugen. Dazu mountet man die ISO und l√§dt im Windows System Image Manager das Image (install.wim) aus der ISO. Anschlie√üend w√§hlt man die gew√ºnschte Version von Windows Server, zum Beispiel Server Standard oder Server Datacenter. F√ºr die Kunden-VMs w√§hlen wir Server Standard. Bevor wir eine Antwortdatei erstellen k√∂nnen, muss zun√§chst eine Katalogdatei erzeugt werden. Sobald diese vorliegt, kann die Antwortdatei erstellt werden.

Alle relevanten Optionen finden sich im Windows Image Fenster unter ‚ÄûMicrosoft-Windows-Shell-Setup‚Äú. Wichtig ist vor allem der Unterpunkt ‚ÄûOOBE‚Äú, um viele Schritte bei der Ersteinrichtung von Windows zu √ºberspringen. Zus√§tzlich l√§sst sich dort auch ein weiterer lokaler Benutzer im Abschnitt ‚ÄûUserAccounts‚Äú anlegen. Um eine Option in die Antwortdatei einzuf√ºgen, w√§hlt man per Rechtsklick den passenden Teil der Antwortdatei aus. Dies ist wichtig, da OOBE verschiedene Phasen hat, in denen unterschiedliche Konfigurationen greifen. Den OOBE-Abschnitt k√∂nnen wir nur unter oobeSystem einordnen, daher haben wir hier keine Wahl.

Tests:
Beim testen der Geschwindigkeit auf verschiedenen Maschinen wird die VM mit 2 Kernen und 2GB ram erstellt.

% Refs
\bibliography{ref}
\end{document}

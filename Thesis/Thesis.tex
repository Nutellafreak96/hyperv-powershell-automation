\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

% Math packages
\usepackage{amsmath,amssymb,amsfonts}

% Algorithms
\usepackage{algorithmic}

% Figures and graphics
\usepackage{graphicx}       % For including graphics
\usepackage{float}          % For figure placement control
\usepackage{subcaption}     % For subfigures

% Text and fonts
\usepackage{textcomp}       % For special symbols like °

% Colors
\usepackage{xcolor}         % For color definitions

% Tables
\usepackage{booktabs}       % For professional-looking tables

% Bibliography
\usepackage[numbers,sort&compress]{natbib}
\bibliographystyle{unsrtnat}

% Encoding and spacing
\usepackage[utf8]{inputenc} % UTF-8 support
\usepackage{titlesec}       % For customizing section titles
\usepackage{setspace}       % For line spacing control

\definecolor{HKS66}{RGB}{118,185,0}

%verbesserte Datums ausgabe
\usepackage[ddmmyyyy]{datetime}
\renewcommand{\dateseparator}{.}

\begin{document}

\begin{titlepage}
    \thispagestyle{empty}
    \parindent=0pt
    \begin{minipage}[b]{0.35\textwidth}
        \includegraphics[width=\textwidth]{Pictures/htw-berlin_logo.jpg}
    \end{minipage}
    \begin{minipage}[b]{0.65\textwidth}
        ~
    \end{minipage}

    \vspace{0.5em}
    \textcolor{HKS66}{\rule{\linewidth}{0.4mm}}

    \vspace*{\stretch{0.5}}

    % === TITEL UND ART DER ARBEIT ===
    \begin{center}
        {\LARGE\bfseries\color{HKS66} Skriptgesteuerte Erstellung und Konfiguration von Windows-basierten virtuellen Maschinen in Hyper-V mittels PowerShell} \\[1em]
        \textcolor{HKS66}{\rule{\linewidth}{0.4mm}}\\[1.5em]
        {\LARGE\bfseries Bachelorarbeit}
    \end{center}

    \vspace*{\stretch{0.5}}

    % === AUTOR UND HOCHSCHULE ===
    \begin{center}
        \normalsize % (Standardgröße) — du kannst hier z. B. \large draus machen
        von\\[2ex]
        {\bfseries\large\fontsize{14pt}{16pt}\selectfont Kevin Hübner}\\[2ex]
        Matrikelnummer: 570746\\[4ex]
        {\bfseries\fontsize{13pt}{15pt}\selectfont Fachbereich 1: Computer Engineering}\\
        Hochschule für Technik und Wirtschaft Berlin\\[2ex]
    \end{center}

    \vspace*{\stretch{1}}

    % === DATUM ===
    \begin{center}
        {\Large Datum: Berlin, \today}
    \end{center}

    \vspace*{\stretch{1}}

    % === BEGUTACHTER ===
\begin{center}
    \begin{tabular}{ll}
        {\bfseries\large Erstgutachten:} &  \\
        {\bfseries\large Zweitgutachten:} &  \\
    \end{tabular}
\end{center}

    \vspace*{\stretch{2}}

    \textcolor{HKS66}{\rule{\linewidth}{0.4mm}}

\end{titlepage}


\newpage

Theorie:
- PowerShell
- Hyper V / Failovercluster
    - %https://d1wqtxts1xzle7.cloudfront.net/67117145/Benchmarking_the_Performance_of_Microsof20210505-17699-j1sicg.pdf?1738414388=&response-content-disposition=inline%3B+filename%3DBenchmarking_the_Performance_of_Microsof.pdf&Expires=1754378862&Signature=RcQUcGdtIdVThfq~KQwpd1Mhlu1Gi7eJ0IHp-s3QmbQzw~IWOmBXHWxwhm7u-E8WV8BRwc39B13YzHA8qFK0~AdbZrPkfIzpR8uc-3WzoAa4NtFEUx0SMN~N7FYnls8y10jem9~FxcF6TszNB~j9SqSazGu2RjDbm3w09DbYWmmxE~2bJaAUU8cCSCZ9dMxGTVWkRPf68DcdPKp-NTvUdgMtPWVT~2O5SmrmWenthcI73SKH~D8SKrU3WZg8jNI731-B-Q8lxTeYDo8IBpf6J9r9atNdVYycWszi2hE2l0dXdJ8OQ-FBjR9SXcryqfrbkGvD6KhA9PWD0OlpL55NXQ__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA
    - two variants hyper v on windows and on windows server
    - requires a processor with hardware assisted virtualizaton
    - based on micro kernelized hypervisors 
        - host os provides drivers
        - virtualizaton runs in the parent partition and has access to hardware devices
        - parent creates child
            - childs have no access to hardware
    -%https://acta.fih.upt.ro/pdf/2016-2/ACTA-2016-2-15.pdf (performance analysis of server system virtualization implemented using hyper v hypervisor)
        - works on the os. 
        - runs on the hardware, under the os
    - % https://www.fujitsu.com/global/documents/about/resources/publications/fstj/archives/vol47-3/paper16.pdf(Windows Server 2008 R2 Hyper-V Server Virtualization)
        - microkernel-based hypervisor 
        - lies above the hardware under the os
        - windows driver stack is embedded in the management os (parent partition)
        - driver compatible with the os can be embedded in the virtualization platform
        - I/O opperations are communications between guest os and management os vis VMBus
        - 
- Sysprep
- WinRM vs WindowsDirect (Powershell WindowsDirect)
Ziel:
- Automatisierung Servererstellung und Konfiguration (Chambionic)
    - Testbenutzer
    - adminbenutzer
    - lokaler admin
    - GPOs
    - Freigaben
    - Datev vorbereitungen (ordner zugriffsrechte)
- zeitersparnis durch skriptgesteuerte Erstellung
- umgehung nerviges durchklicken durch gui elemente
- unnötiges eingeben von einzelnen daten umgehen
- zeitersparnis bei der installation von windows da template

Durchführung:
- VHD(X) vorbereiten
    - Win Server 2025 iso runterladen
    - VM erstellen mit der iso als boot option
    - windows installieren, wie gewohnt (Windows Server 2025 Evaluation Datacenter [Desktopdarstellung])
    - beim festlegen des Adminpasswortes Strg+Shift+F3 -> start in den audit modus
    - unattend.xml unter C:\ ablegen (unattend.xml aus dem ordner "Serverpreparations")
    - sysprep über admin cmd starten mit sysprep /oobe /generalize /shutdown /unattned:filepath
    - vm nicht neustarten!!!
    - vhd(x) der vm in ordner "Serverpreparations" speichern unter dem namen Serverprep.vhdx
- Skript starten
    GUI
    - Abfrage des Speicherortes der zu erstellenden VM
    - Abfrage des Speicherortes der zu importierenden gpo, zu kopierenden vhdx,xml fs rollen installation, xml für die gpo
    - Abfrage der Daten wie Kundenname, OU name, Domain name, NetBios name, Server Ip addressen, passwörter für drms, test user, admin user, standard admin
    - Abfrage des zu verwendenden hyper v switch (netzwerkschnittstelle) 
    - Abfrage der anzahl der kerne für die VMs
    - Abfrage zur RAM Nutzung der VMs
    Skript
        - Aufteilung in Ordner 
        - Main.ps1 ist, wie der Name schon sagt, das Main Skript zum ausführen der Befehle und Skripte 
    - Ordner ActiveDirectoryHandling
        - ADUserGroups -> Create 2 Users and a few standard groups -> puts users into groups
        - OrganizationalUnitStructure -> Create OUs and move severs to correct OU
        - RegistryGroupPolicies -> Create Registry based Grouppolicies and import changed gpo via xml
    - Ordner FileHandling
        - DirectoryPreparations -> initialising a new drive to the fs vm and creating directorys to later share in the network
        - FilehandlingFunctions -> Create file structure, remove sensitive files needed to configure win installation, copy files to VMs
        - Permissions -> handle directory permissions (set access permissions to different adgroups)
    - Ordner VMhandling
        - ChangeIpRenameDc -> disable ipv6, rename Computer and set static ipv4
        - ChangeIpRenameTs -> disable ipv6, rename Computer and set static ipv4
        - VmHandlingFunctions -> ckeck redyness of vm, change vm rescressources, active scripts and set static mac to networkadapter 
    - Ordner UserInterfaceFunctions
        - all userinterface functions to get information from the user
    
- Fehler oder Sonstiges
- Verbesserungen/Erweiterungen/Ideen
    - 


    - händisch sind das von unerfahrenen nutzern ca 2h und von erfahrenen nutzern zwischen 1:15 und 1:30
    - auf altem testserver 40 min bestzeit bei großer hitze bis zu 1h

Vorgehensweise:


\section{Projektidee und Ausgangssituation}

Die Idee zu diesem Projekt entstand aus der praktischen Arbeit im Bereich Windows-Server-Administration, in dem nahezu ausschließlich mit Windows Server und Hyper-V gearbeitet wird.
In der bisherigen Vorgehensweise erfolgt die Erstellung neuer virtueller Maschinen (VMs) in einem Failover-Cluster (Hyper-V) vollständig manuell – beginnend bei der VM-Anlage bis hin zur vollständigen Konfiguration des Betriebssystems und der benötigten Rollen.
Ein typisches Szenario tritt auf, wenn ein neuer Kunde im Rechenzentrum eingerichtet wird und in der Standardkonfiguration einen Domänencontroller (DC), einen Dateiserver (FS) sowie einen Terminalserver (TS) erhält.
In diesem Fall müssen drei VMs erstellt und jeweils mit Windows Server installiert werden.
Bei kleineren Kunden kann es vorkommen, dass nur eine oder zwei VMs eingesetzt werden, jedoch wird in dieser Arbeit der Drei-VM-Ansatz betrachtet.
Diese Trennung der Rollen hat den Vorteil einer klaren Aufgabenverteilung, einer besseren Übersicht und einer optimierten Lastverteilung zwischen den Systemen.
Die manuelle Einrichtung umfasst zahlreiche wiederkehrende Arbeitsschritte.
Auf dem Dateiserver werden Festplatten für den Speicherplatz angebunden, Ordnerstrukturen angelegt, Freigaben erstellt und NTFS-Berechtigungen vergeben.
Auf dem Terminalserver erfolgt die Installation und Konfiguration der Remotedesktopdienste, wobei im betrachteten Szenario eine sitzungsbasierte Bereitstellung umgesetzt wird.
Dies umfasst die Installation der benötigten Rollenkomponenten wie Connection Broker, Lizenzserver und Session Host.
Zusätzlich wird eine Session Collection für den Kunden angelegt und einer Active-Directory-Gruppe zugewiesen, die für den Zugriff per Remote Desktop autorisiert ist.
Die Lizenzierung muss dabei der geplanten Benutzeranzahl entsprechen.
Eine häufig genutzte Ausnahme stellt die DATEV-Anwendung dar, die in vielen Kundenszenarien eingesetzt wird.
Diese wird aus technischen Gründen meist auf dem Dateiserver installiert, kann jedoch bei größeren Anforderungen auch auf einer dedizierten VM betrieben werden, da sie SQL-Datenbanken mitbringt und entsprechende Ressourcen benötigt.
Die Aktualisierung von DATEV erfordert eine koordinierte Vorgehensweise auf allen beteiligten Systemen und kann zu temporären Verbindungsunterbrechungen führen.
Der Domänencontroller nimmt in diesem Aufbau eine zentrale Rolle ein, da er Benutzer, Gruppen und Gruppenrichtlinien für alle Systeme der Domäne bereitstellt und verwaltet.
Erst nach seiner vollständigen Einrichtung können die anderen VMs der Domäne beitreten, sodass Zugriffsrechte und Gruppenrichtlinien wie vorgesehen greifen.
Zudem bietet er die Möglichkeit, organisatorische Einheiten (OUs) anzulegen, um die Verwaltung von Computern, Servern und Benutzern zu strukturieren.

Die bisherige manuelle Vorgehensweise erfordert eine Vielzahl von Einzelschritten, darunter: Vergabe statischer IP-Adressen, Umbenennung der Rechner, Einbindung zusätzlicher Festplatten, Erstellung von Standard-Benutzern und -Gruppen, Konfiguration von Gruppenrichtlinien sowie Vergabe und Freigabe von Ordnerberechtigungen. Zwar können Gruppenrichtlinien importiert werden, jedoch müssen deren Sicherheitskennungen (SIDs) an die neue Domäne angepasst werden, um die korrekte Funktionsweise sicherzustellen.

Das im Rahmen dieser Arbeit entwickelte PowerShell-Skript automatisiert große Teile dieser wiederkehrenden Aufgaben. Der Benutzer muss nicht mehr durch zahlreiche grafische Dialoge navigieren oder auf manuelle Zwischenschritte warten. Der Automatisierungsgrad ist bewusst so gestaltet, dass nach einer einmaligen Vorbereitung eines Windows-Server-Templates alle weiteren Konfigurationsschritte skriptgesteuert erfolgen können. Das Skript erstellt und konfiguriert drei VMs (DC, FS, TS), richtet die grundlegenden Rollen ein, erstellt Standard-Benutzer und -Gruppen, legt Ordnerstrukturen an, vergibt NTFS-Berechtigungen, setzt statische IP-Adressen und vergibt Computernamen. Das Ergebnis sind einsatzbereite VMs, die lediglich noch aktiviert und im Fall des Terminalservers mit einem Lizenzserver für Remotedesktop-Sitzungen verbunden werden müssen.

Für die Vorbereitung wird zunächst eine VM mit Windows Server installiert und mithilfe des Windows-eigenen Sysprep-Tools generalisiert. Hierfür wird eine vorgefertigte Antwortdatei (\texttt{unattend.xml}) verwendet, die vor der Generalisierung in das System kopiert wird. Nach dem Start im Audit-Modus (über \texttt{Strg + Umschalt + F3}) und dem Platzieren der Antwortdatei im Verzeichnis \texttt{C:\textbackslash Windows\textbackslash System32\textbackslash Sysprep} kann die Generalisierung über den Befehl
\begin{verbatim}
sysprep.exe /oobe /shutdown /generalize /unattend:C:\Windows\System32\Sysprep\unattend.xml
\end{verbatim}
durchgeführt werden. Die resultierende VHDX-Datei (\texttt{Serverprep.vhdx}) dient als Template für die automatisierte Erstellung der zukünftigen VMs.
---

\section*{Weitere technische Erkenntnisse}

Während der Entwicklung und Umsetzung des Automatisierungsskripts für Hyper-V traten eine Vielzahl technischer Besonderheiten und Fallstricke auf, die bei zukünftigen Projekten berücksichtigt werden sollten. Eine grundlegende Voraussetzung für bestimmte Aktionen, wie beispielsweise den Domänenbeitritt, ist die Verwendung eindeutiger SIDs. Dies wurde durch den Einsatz von \texttt{sysprep} in Verbindung mit einer funktionierenden Antwortdatei sichergestellt. Dabei zeigte sich, dass die Antwortdatei strikt in der Reihenfolge von oben nach unten abgearbeitet wird, weshalb der \texttt{OOBE}-Abschnitt möglichst früh platziert werden sollte.  

Im Bereich der Skripterstellung mit PowerShell war besonders bei der Arbeit mit GUIs und Benutzerinteraktionen Aufmerksamkeit erforderlich. So erwies es sich als sinnvoll, beim Aufbau einer RAM-Auswahl Integer-Werte in Byte-Form anzugeben, da Strings in Arrays nicht zuverlässig verarbeitet wurden. Das Rückgabeverhalten wurde über \texttt{return} angepasst, um korrekte Werte zu liefern. Außerdem zeigte sich, dass in PowerShell die Überprüfung auf \texttt{NULL} konsistent mit der Schreibweise \texttt{NULL -eq \$Variable} erfolgen sollte, um logische Fehler -- insbesondere bei Array-Prüfungen -- zu vermeiden.  

GUI-Fenster verhielten sich in Bezug auf die Anzeige im Vordergrund nicht immer wie erwartet, selbst wenn die Eigenschaft \texttt{TopMost} gesetzt war. Dieses Problem wurde durch die Definition eines Mutterfensters und die gezielte Anzeige untergeordneter Fenster mit \texttt{.Add\_Shown()} gelöst. Passworteingaben ließen sich in der GUI zwar ausblenden, mussten jedoch für die weitere Verarbeitung mittels \texttt{ConvertTo-SecureString -PlainText} in ein SecureString-Format konvertiert werden. Beim Auswählen von Verzeichnissen war zu beachten, dass der Pfad über die Eigenschaft \texttt{InitialDirectory} und nicht \texttt{RootFolder} festgelegt werden muss.  

Für die Eingabevalidierung, beispielsweise bei IP-Adressen, bot sich die Nutzung regulärer Ausdrücke wie \texttt{"[0-9]+\textbackslash.[0-9]+\textbackslash.[0-9]+\textbackslash.[0-9]+"} an. Variablen, die innerhalb von Remote-Jobs oder Sessions genutzt werden, mussten mit dem Präfix \texttt{Using:} übergeben werden -- auch dann, wenn sie zuvor global deklariert wurden. Innerhalb von Strings war eine Variablenersetzung nur mit der Schreibweise \texttt{\$(Variable)} möglich. Bei Abfragen, die einen String erfordern, erwies sich die Verwendung des Parameters \texttt{-ExpandProperty} als notwendig, um Objektrückgaben zu vermeiden.  

Das Ausführen von Befehlen mit dem Parameter \texttt{-AsJob} startete Prozesse im Hintergrund, was problematisch sein konnte, wenn das Ergebnis sofort benötigt wurde. In solchen Fällen war es erforderlich, den Job aktiv zu überwachen, das Ende der Ausführung abzuwarten und anschließend den Job zu entfernen. Beim Einsatz von \texttt{Invoke-Command} konnte entweder direkt mit VM-Namen oder mit zuvor erstellten Sessions gearbeitet werden; letztere mussten nach Abschluss wieder geschlossen werden. Um Anmeldevorgänge zu vermeiden, konnten Anmeldeinformationen als \texttt{PSCredential}-Objekte hinterlegt werden. Diese wurden über \texttt{New-Object} erstellt, wobei das Passwort als SecureString abgefragt und zusammen mit dem Benutzernamen in einer Variablen gespeichert wurde.  

Vor der Ausführung des Skripts wurde geprüft, ob es in einer administrativen Sitzung lief. Falls nicht, wurde es über \texttt{Start-Process} mit dem Verb \texttt{RunAs} neu gestartet. Für eine einheitliche Protokollierung wurde eine Log-Funktion erstellt, die Zeitstempel im Format \texttt{"[dd/MM/yy HH:mm:ss]"} generierte. Nicht benötigte Ausgaben wurden konsequent mit \texttt{| Out-Null} unterdrückt.  

Netzwerkanpassungen innerhalb von Windows-VMs erfolgten mit \texttt{New-NetIPAddress} anstelle von \texttt{Set-NetIPAddress}. Um Dateien vom Hyper-V-Host auf eine VM zu übertragen, musste die Gastdienstschnittstelle aktiviert werden, was über \texttt{Enable-VMIntegrationService} möglich war. Anschließend konnte der Kopiervorgang mit \texttt{Copy-VMFile} durchgeführt werden, wobei Systempfade nur indirekt beschreibbar waren.  

Die Installation bestimmter Serverrollen, wie des Dateiservers, war nur über XML-basierte Konfigurationen möglich. Remote Desktop Services (RDS) konnten vom Domänencontroller auf den Terminalserver installiert werden, wobei zusätzliche Konfigurationen -- etwa Session Collections, RDS-Lizenzierung und Neustarts des Verwaltungsdienstes -- direkt auf dem TS erfolgten.  

Weitere Besonderheiten betrafen die Handhabung von Strings, Hash-Tabellen und VM-Eigenschaften: Beim Splitten eines Strings am Punkt musste der Punkt mit \texttt{"\textbackslash."} escaped werden. VMs konnten vollständig aus Hash-Tabellen heraus erstellt werden, wobei CPU-Anpassungen erst nach der Erstellung und MAC-Adressänderungen nur nach dem ersten Start möglich waren. Neue virtuelle Festplatten wurden per \texttt{Add-VMHardDiskDrive} angebunden, anschließend online geschaltet, benannt, mit einem Laufwerksbuchstaben versehen und formatiert.  

Passwörter von Active-Directory-Konten ließen sich nicht ohne Weiteres zurücksetzen, während lokale Passwörter per Remote- oder PowerShell-Direct-Zugriff problemlos geändert werden konnten. Bestimmte Installationsfehlermeldungen bei RDS ließen sich möglicherweise auf fehlende Lizenzserverkonfigurationen zurückführen.

---

Skript:


\chapter{Fazit und Ausblick}

Im Rahmen dieser Arbeit wurde ein PowerShell-basiertes Automatisierungsskript entwickelt, das die Erstellung und Konfiguration von Windows-basierten virtuellen Maschinen in einer Hyper-V-Umgebung ermöglicht.  
Die Ergebnisse der praktischen Tests zeigen, dass mit dem Skript eine vollständige und funktionsfähige Basisumgebung innerhalb von 20 bis 40 Minuten bereitgestellt werden kann – abhängig von der verfügbaren Systemleistung.  
Damit konnte die für die manuelle Bereitstellung übliche Dauer von mehreren Stunden deutlich reduziert werden.  
Während der Testphase traten lediglich kleinere Fehlermeldungen auf, beispielsweise im Zusammenhang mit der Einrichtung der Session Collection oder gelegentlichen Abbrüchen von Remoteverbindungen.  
Diese hatten jedoch weder in den Testumgebungen mit Domänenanbindung noch im Betrieb mit Testbenutzern spürbare Auswirkungen auf die Funktionalität.

Die durchgeführten Tests auf unterschiedlichen Hardwarekonfigurationen – sowohl auf einem Server mit Intel Xeon~E3-1230\,v5, 64\,GB RAM und SSD-RAID als auch auf einem leistungsstarken Desktop-System mit AMD~Ryzen~7\,7800X3D, 32\,GB DDR5-RAM und NVMe-SSD – bestätigen die hohe Flexibilität und Anpassungsfähigkeit des Skripts.  
Dabei zeigte sich, dass die Ausführungszeit maßgeblich von CPU- und Speicherperformance sowie der I/O-Leistung des Speichersystems beeinflusst wird.

Trotz des erreichten Funktionsumfangs bestehen mehrere Potenziale für zukünftige Verbesserungen.  
Hierzu zählt die Möglichkeit, für kleinere Kundenumgebungen nur ein oder zwei Server bereitzustellen, wodurch Ressourcen und Zeit eingespart werden könnten.  
Eine flexible Anpassung des der virtuellen Maschine zugewiesenen Speichers – idealerweise über eine grafische Benutzeroberfläche (\textit{GUI}) – würde zudem die Bedienbarkeit und den Einsatzbereich erweitern.  
Auch die vollständige Automatisierung zusätzlicher Terminalserver-Konfigurationen, wie etwa die Lizenzserver-Einrichtung, könnte den manuellen Administrationsaufwand weiter reduzieren.  

Für den Einsatz in hochverfügbaren Umgebungen wäre eine Anpassung an Failover-Cluster-Architekturen erforderlich.  
Dies erfordert die Erweiterung des Skripts um clusterrelevante Rollen und Eigenschaften, da es bislang ausschließlich in Einzelhost-Szenarien getestet wurde.  
Ein weiteres Optimierungspotenzial liegt in der Ablösung der derzeitigen statischen Wartezeit nach der Installation des Domänencontrollers durch ein dynamisches, ereignisgesteuertes Verfahren, um die Bereitstellungsdauer zu verkürzen und die Professionalität der Umsetzung zu erhöhen.  
Darüber hinaus könnte die Benutzeranlage durch den Import vordefinierter XML-Dateien automatisiert werden, was die Konsistenz und Wiederholbarkeit der Konfiguration verbessern würde.

Insgesamt zeigt die Arbeit, dass durch den gezielten Einsatz von PowerShell-Skripten in Verbindung mit Hyper-V eine deutliche Effizienzsteigerung in der Serverbereitstellung erreicht werden kann.  
Die skizzierten Verbesserungsansätze bieten darüber hinaus ein hohes Potenzial für zukünftige Entwicklungen, insbesondere im Hinblick auf Flexibilität, Skalierbarkeit und Integration in komplexere IT-Infrastrukturen.

\newpage

Text:\\

Idee:
Automatisieren einer Serverstruktur in Hyper V. Dabei wird bedacht, dass es einen Domain Controller, ein Fileserver und ein Terminalserver gibt. Die Erstellung soll ebenfalls das erstellen von freigegebenen Ordnern und Gruppenrichtlinien sowie ein Domain Admin und Test User für die Firma beinhalten. Zudem soll die Installation von Windows durch ein VM Template umgangen werden.

Stand in der Firma:
Alles wird händisch über die GUI in Windows gemacht. Zudem wird auf jeder VM Windows installiert. Selbst Gruppenrichtlinien, welche man über Powershell erstellen kann oder User/Gruppen werden über Powershell erstellt. Das ist, vor allem, heutzutage unprofessionell mit den Möglichkeiten die Windows einem Bietet. 

Vorgehensweise:
Der erste Schritt für das Skript ist natürlich die Erstellung eines VM Templates. Das wird einmalig händisch erstellt und dabei muss man auch nur einmal Windows Server installieren. Was ebenfalls wichtig ist, ist das erstellen einer Antwortdatei (unattend file) im XML Format. Das kann man ohne Problem mit der ISO von Windows Server und dem Windows eigenen Windows System Image manager machen. Man mountet die Iso und kann dann im Windows System Image Manager das Image (install.wim) aus der iso laden. Mann muss nur seine Gewünsch Version von Windows Srer auswählen wi z.b. ServerStandard oder Server Datavcenter. ir wälen für die Knden VM ServerStandard und müssen nun eine Kaqtalogdatei erstellen lassn bevor wir eine Antwortdatei erstellen können. Ist die KAalogdatei fertig können wir eine neue antwort datei erstellen.  Alles was wir brauchen finden wir im Windows Image Fester unter Microsoft-Shell-Stup. Wichtig ist der utnerpunkt OOBe um viele Sachen bei der Window ersteinrichtung zu überspringen. Zusätzlich können wir auch noch einen zusätzlcihen lokalen user erstellen im unterpunkt UserAccouts. Um die Optionen der Antwortdatei hinzuzufügen muss man mit rechtsklick auswählen in welchen teil der antwortdatei man das schreiben möchte. Das ist wichtig, denn der oobe von Windows ha verschiedene stadien in denen verschiedene sachen eingerichtet werden. OOBE können wir jedoch nur unter oobeSystem einordnen, deswegen haben wir da auch keine Wahl.
Hat man die XML erstellt, was man neben der Installation von Windows Server hervorragend machen kann, so muss man nach der Installation von Windows Server die Vergabe des Adminpasswortes mit der Tastenkombination STRG+Shift+F3 umgehen. Damit startet man Windows in den Audit Modus. In diesem Modus kann man sich die Windows-Installation so anpassen wie man es benötigt. Für das Skript ist es nur wichtig, dass der lokale Administrator ein Passwort hat, man zusätzlich einen lokalen Admin erstellt und man jegliche Einstellungen bei der ersten Benutzung mit der XML Datei überspringt. In der XML des GitHub Projekts wird noch zusätzlich das Sprachenlayout auf Deutsch gestellt. Das einmalige installieren auf einem guten Rechner oder Server dauert dann einmalig 5-10min.
Diese XML schreibt man dann in den Pfad indem auch das Systemvorbereitungstool Sysprep von Windows liegt. Dieses liegt in der Regel unter  c-windows-system32-sysprep. Wenn dort die unattend.xml (anderer Name kann auch gewählt werden) abgelegt oder angelegt wurde, dann kann mit der Administrator Eingabeaufforderung (CMD)  Sysprep mit den Parametern oobe, shutdown, generalize und unattend:(Pfad der XML) ausgeführt werden. Die erstellte VM wird die Installation generalisieren d.h. die Installation unabhängig von der VM machen. Somit kann die VM oder besser gesagt die vhd(x) der VM kopiert und wiederverwendet werden ohne das später Probleme zwischen den SID der Adminbenutzer der einzelnen VM auftreten. Nachdem die Installation generalisiert wurde sollte man die zugehörige VM nicht starten solange man die vhd(x) nicht kopiert hat. Denn sonst macht man seine Generalisierung zunichte.
Nun gehen wir in den nächsten Schritt: die Erstellung von VMS mittels Powershell. Den Ablauf zum manuellen erstellen kennt man schon sehr gut auch durch andere Virtualisierungs Möglichkeiten. Man gibt der VM einen Namen, einen Speicherort, die Menge an RAM, einen Netzwerkadapter, die Anzahl an CPU Kernen.und die größe der Festplatte die für die Bootpartition, Windows etc. Da wir schon eine vhdx für die Bootpartition haben können wir das überspringen. Der Fileserver braucht noch zusätzlich eine Festplatte um die Daten der Nutzer zu speichern. Diese wird beim erstellen der VM miterstellt und beim FS gemountet. Sonst müssen wir über Powershell nur das machen was wir auch mit der GUI machen würden. Wir kopieren das vhd(x) Template an den Ort wo die VM gespeichert werden soll und geben den Pfad, sowie einen Namen für die VM an. Nachdem erstellen weisen wir der VM die Menge an RAM und CPU Kernen hinzu und dann ist die Erstellung fertig und die VM kann gestartet werden. 
Nun können wir alles was wir brauchen in einer VM erstelllen und Testen. Dabei ist das vorgehen immer das selbe. Wir testen wie man das manuell macht und dann schauen wir wie wir genau das selbe Ergebnis erzielen nur mit PowerShell.
Bevor wir zum nächsten Schritt voranschreiten muss noch eine kleine Sache für die NEtzwerkadapter der Vm eingestellt werden. Da die Maschinen über TeamViewer angesteuert werden muss die MAC Adresse des Netzwerkadapters der VM statisch sein. Sonst verschwindet der Server in der Liste der Hinzugefügten Geräte in TeamViewer. Dafür muss die VM einmal gestartet werden und in Windows booten damit der NEtzwerkadapter eine MAC addresse bekommt. Dann wird die VM heruntergefahren in Hyperv die mac addresse auf statisch gesetzt und dann kann man wieder normal damit weiter arbeiten.
So nachdem wir nun wissen wie man eine VM mit PowerShell erstellt müssen wir auch für die Kunden eine Ordnerstruktur erschaffen damit man die VM ordentlich trennen kann. Dafür schreiben wir ein kleines Skript(FilehandlingFunctions), was wir aufrufen um für jeden Kunden die gleiche Ordnerstruktur aufzubauen nur mit dem unterschied, dass jeder Kunde seine eigene Struktur unter seinem namen hat. In der Struktur werden die vhd(x) aus dem Vorbereitungsordner in die unterordner der Kundenstruktur kopiert. Bevor jedoch diese Ordnerstruktur errichtet wird muss überprüft werden ob diese nicht schon existiert. Das ist recht simples file handling und mit NEw-Item können wir auch ganz einfach neue Ordner erstellen. Zudem bekommt jede Kundenstruktur auch ihr eigenes Logfile in das wir schreiben können um fehler zu entdecken oder zu wissen wo das SKript gerade ist oder es hängen bleibt. 
Da wir ein vhd(x) template nutzen um VM zu erstellen wird es in diesen Installationen auch immer die unattend.xml mit den Adminpasswörtern geben. Diese sind ein Sicherheitsrisiko, welches vermieden werden können und deswegen wird nach dem Erstellen der Ordnerstruktur des Kunden und nach dem erstellen der VM die unattend Datei in den VMs, mithilfe einer Function aus dem Skript FileHandlingFunctions, gelöscht.
Bei der Erstellung des Skripts habe ich mich mit variablen und ihrem Wirkungsbereich. Dabei fällt auf, dass man variablen vom hauptskript in das unterskript mitnehmen kann, diese jedoch mit "Using" kennzeichnen muss. Deswegen ist es einfacher functionen mit Parametern zu schrieben um die variablen mitzunehmen. So handhabt man das Quasi wie in C7C++ mit den headerfiles und codefiles, nur das man keine wirklichen Header hat. Man hat ein Skript das man einbindet um die Functionen daraus zu verwenden oder um es mit invoke-command remote in einer Maschine auszuführen. Da kommen  wir jedoch zum nächsten Problem. Der Befehl invoke-command kann, von hyperv host, ohne Probleme befehle in der VMs ausführen. DAs funktioniert über PowerShell Direct. Jedoch gibt es auch die Möglichkeit über das Netzwerk mit WindowsRemoteManagement (WinRM) befehle auszuführen und da kann man auf das Kerberus doublehop Problem stoßen.

Bevor wir die Rollen in den VMs installieren können wollen/müssen wir den VM bzw den installationen eine statische ip geben und dem FS sowie dem TS den DC als DNS Server geben. Zudem wollen wir ebenfalls den Computernamen anpassen um zu wissen um was für ein Computer es sich handelt. Dafür haben wir dann für jede VM ein kleines Skript.(ChangeIpRenameTs bzw ChangeIpRenameDc)
Nun zum nächsten Schritt der Domain Controller. Wenn man diesen manuell einrichtet, kann man sich, bevor man diesen hochstuft, ein Skript ausgeben lassen, welches das gleiche machen würde wie man es manuell getan hat. Das Skript gibt uns kleine Einblicke über das was wir brauchen, aber auch Microsoft hat eine Seite dafür und dort finden wir alles was wir benötigen. Wir erstellen eine Hashmap mit allen nötigen Informationen wie Domainname,Netbiosname,DSRM Password, Pfaden für Systemdateien und Logdateien. Dann installieren wir die notwendige rolle und mit Install ADDSForest und unserer Hashmap können wir den Domaincontroller hochstufen und nach einem Neustart haben wir die Grundkonfiguration fertig. Vor dem Neustart fügen wir noch den Google dns Server (8.8.8.8) in die liste der DNS Weiterleitungen.
Beim Fileserver müssen wir jedoch anders vorgehen, da es eine unterrolle ist, ist es nicht so einfach mit Powershell zu installieren. Jedoch kann man auch hier xml Dateien verwenden und bei der manuelles installation bekommt man am ende eine xml datei die man dafür verwenden kann. Da es auch keine speziellen Einstellungen bei der Manuellen installation gibt ist es auch irrelevant denn die Rolleninstallation ist auf jedem System gleich. Das einzige Problem ist, dass die XMl auf dem Zielsystem sein muss. Dafür gibt muss in der VM die "Gastdienstschnittstelle" aktiviert werden um dann die Datein in die Vm kopieren zu können. Bevor wir notwendige Dateien kopieren erstellen wir einen Ordner in den VMs in denen wir die Dateien dann kopieren. Für den DC sind es später eine Gruppenrichtlinie und eine Datei für eine Gruppenrichlinie. Für den FS die xml zum installieren der Rolle. Das installieren der Rolle passiert zusammen mit dem einstellen der statischen IP addresse, da es eine vom DomainController unabhängige Rolle ist.(DeployFileServerRole)
Im jetzigen Stand des Skriptes haben wir 3 Vms und auf zweien ist schon die Richtige Rollle installiert und wir haben auch einen funktionierenden Domain Controller. Der nächste SChritt ist es, nachdem der Domain Controller bzw das Windows des DC gebootet hat die anderen Server in die Domäne aufzunehmen. Das lässt isch ganz einfach über eine kleine Funktion lösen, welche mit dem invoke-command befehl von der VM aus der Domäne beitreten. Durch rumprobieren mit dem VM Template weiß ich auch, dass beim falschen generalisieren oder fehlerhaften unattend files das problem besteht, dass der lokale Administrrator immer die gleiche ID hat und deswegen könnte es fehlschlagen der Domäne des DC beizutreten. Somit muss man acht geben wenn man die unattended anlegt. Nach dem erstellen der VMs kann man mit "Get-LcoalUser -Name ADministrator | FL" die SID der Administratoren verlgeichen. Sind diese gleich so hat die generalisierung mit sysprep nciht funktioniert und das Skript wird fehlschlagen. Langsam kommen wir zu den kniffligen Sachen. WEnn die Computer der Domaine beigetreten sind fehlt uns nur noch eine Rolleninstallation und dann eine Grundstructur für die Active Directory sowie Freigegebene Ordner für Benutzer und Gruppenrichtlininen. 
Jetzt bereiten wir den FS mit der hinzugefügten Festplatte vor (DirectoryPreparations). Diese muss in der Windowsinstallation des Fileservers auf online gestellt und mit dem Partitionsstil GPT initialisiert werden. Danach wird eine Partition mit der gesamten größe der Festplatte erstellt und mit einem Namen und einem Laufwersbuchstaben versehen. Im Skript ist das der Buchstabe D und dazu den passende Name Daten. Danach werden noch alle wichtigen Standardordner erstellt.
Nun fehlen für die Ordner nur noch die Freigaben und Zugrifssrechte. Das ist wiederum an Ad-Gruppen geknüpft und deswegen müssen wir erstmal eine Grundstruktur in der Active Directory erstellen. Das heißt wir brauchen einen testuser und einen adminuser für uns selbst (Chambionic), die Standardgruppen wie Scan_Lw, Datevuser, Daten_LW, GF für Geschäftsführung, eine struktur für die einzelnen Objekte in verschiedenen Unterorganisationseinheiten (Benutzer,Gruppen,Computer etc). Die nutzer legen wir dabei über hashmaps an, so ähnlich wie bei der Rolleninstallation des DomainControllers, und die gruppen einfach über den befehl New-AdGroup. Wenn erstellt fügen wir die zwei Benutzern in den erstellten Gruppen hinzu. Zu einer grundstruktur der active Directory zählen auch die Standard Richtlininen wie netzlaufwerke, remotedesktop einstellungen, sperren der Eingabeaufforderung/ ausführen von skripten und 


% Refs
\bibliography{ref}
\end{document}
